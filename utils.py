# -*- coding: utf-8 -*-
import cv2 
import numpy as np
import openslide
import pyvips
import matplotlib.pyplot as plt
import os
from PIL import Image
Image.MAX_IMAGE_PIXELS = 1000000000

def getprompt(origin_image):
    '''
    Automatic generate bounding box coordinates of the objects inside the input image.
    input:
        origin_image: input image path.
    output:
        prompt_list: bounding box coordinates
    '''
    slide = openslide.open_slide(origin_image)
    #print('origin:',slide.dimensions)
    #print(slide.level_dimensions)
    multiplaying = 5 #縮小係數：2的n次方
    a,b=slide.dimensions
    a_1=a//(2**multiplaying)
    b_1=b//(2**multiplaying)
    slide_thumbnail = slide.get_thumbnail((a_1, b_1))
    tile = np.array(slide_thumbnail)
    gray = cv2.cvtColor(tile, cv2.COLOR_BGR2GRAY)
    _, thresh = cv2.threshold(gray, 200, 225, cv2.THRESH_BINARY_INV)
    contours0, hierarchy0 = cv2.findContours(thresh, cv2.RETR_EXTERNAL, cv2.CHAIN_APPROX_SIMPLE)
    img = tile.copy()
    prompt_list=[]
    for cidx,cnt in enumerate(contours0):
        (x0, y0, w0, h0) = cv2.boundingRect(cnt)
        shift=3
        if w0*h0>=3000:
            return_x=x0
            return_y=y0
            return_w=w0
            return_h=h0
            prompt_list.append([return_x,return_y,return_x+return_w,return_y+return_h])
        else:
            continue
    #imageio.imwrite(output_dir+"CMU-2.png", img)
    print('Generate prompt completed')
    return prompt_list


def load_image(image_path: str, level: int):
    '''
    Load image by using pyvips.
    input:
        input_path: input image path.
        level: the scale of the input image.
    return:
        image: converted image.
    '''
    image = pyvips.Image.new_from_file(image_path, level=level)
    image = image.colourspace("srgb")
    image = image.numpy()
    image = cv2.cvtColor(image, cv2.COLOR_RGBA2RGB)
    #print(image)
    return image


def show_mask(mask, ax, random_color=False):
    '''
    display the masks which generated by segment anything model.
    input:
        mask: segment anything model input.
    output:
        display the images.
    '''
    if random_color:
        color = np.concatenate([np.random.random(3), np.array([0.6])], axis=0)
    else:
        #color = np.array([30/255, 144/255, 255/255, 0.6])
        color = np.array([30/255, 144/255, 255/255, 1])
    h, w = mask.shape[-2:]
    mask_image = mask.reshape(h, w, 1) * color.reshape(1, 1, -1)
    ax.imshow(mask_image)

def show_box(box, ax):
    '''
    display the bounding box that generated by getprompt function.
    '''
    x0, y0 = box[0], box[1]
    w, h = box[2] - box[0], box[3] - box[1]
    ax.add_patch(plt.Rectangle((x0, y0), w, h, edgecolor='green', facecolor=(0,0,0,0), lw=2))

def contour_to_points(contour):
    pointsNum = len(contour)
    contour = contour.reshape(pointsNum, -1).astype(np.float32)
    points=[]
    for point in contour:
        point=point.tolist()
        point[0],point[1]=point[0]*32,point[1]*32
        point.insert(0,'x')
        point.insert(2,'y')
        point=convert(point)
        points.append(point)
    #points = [point.tolist() for point in contour]
    return points

def cal_area(contours):
    '''
    calculate the pixel num of the mask 
    '''
    total_area = 0
    for c in contours:
        area = cv2.contourArea(c)
        total_area += area
    return total_area*8

def convert(lst):
    res_dict = {}
    for i in range(0, len(lst), 2):
        res_dict[lst[i]] = lst[i + 1]
    return res_dict

def generate_json(num,points,total_area):
    shape_dict = {
                    "name": "tissue",
                    "ID": num,
                    "type": "polygon",
                    "partOfGroup": "HCC",
                    "coordinates": points,
                    "area": total_area,
                }
    if num==1:
        json_dict = {
            "annotation": list(),
        }
        json_dict["annotation"].append(shape_dict)
        #json_dict["information"]["Tissue area"] = total_area
        return json_dict
    else:
        return shape_dict
